**Table of Contents**

- [Functional vs non-Functional testing](#functional-vs-non-functional-testing)
  - [(Functional) Software testing](#functional-software-testing)
  - [Test case and Test suite](#test-case-and-test-suite)
  - [Manual vs Automated](#manual-vs-automated)


## Functional vs non-Functional testing

Each software factor can be evaluated using specific types of testing:

Functional Testing

- Targets **correctness** by verifying that the software behaves as expected according to requirements.

Non-Functional Testing

- Examines non-functional aspects such as **efficiency**, **usability**, **reliability**, **security**, and other qualities of the software application.

### (Functional) Software testing

Is a systematic approach attempting to find defects, i.e., bugs in a software system

Goals of Software testing

1. Expose and eliminate bugs as early as possible
2. Increase confidence in software correctness
3. Increase software reliability (i.e., function well under
stated conditions for a specified period of time)

**NOT a goal of testing**: prove correctness, because
exhaustive testing is unaffordable (input domain is
huge!)
– Other techniques to do this, e.g. Model checking

Levels of Software Testing

1. Unit Testing --> Testing of a single
function/class
2. Integration Testing --> individual units are combined and tested as a group
3. E2E Testing (End-to-End Testing) --> Testing the system as a whole through the GUI in real conditions
    - considering network and external systems
    - It is performed from start to finish under real world
scenarios like communication of the application with
hardware, network, database and other applications …


Pros and Cons of E2E Testing

- Good things

    – Hide the complexity of the (backend) system
    – Uniformed interface (the GUI) – only one
    – A testing framework at the front-end can automate the tests
    – Particularly useful (when automated) for regression testing
        (next slide)

- Bad things

    – Time consuming to run
    – Prone to non-determinism problems (Flaky tests, e.g., no internet connection)  
    – Prone to the fragility problem (expensive to maintain)
    – Cannot pinpoint the root cause of failure (Anything in the entire flow could have contributed to the failure)

**Regression Testing**
The goal of regression testing is to ensure that previously developed and tested code still functions as expected after new changes

### Test case and Test suite

Test case = A set of inputs (test data), execution preconditions, and expected outcomes developed for a particular objective, such as to exercise a particular program path or to verify compliance with a specific requirement

Test suite = A collection of test cases

How to find good inputs (test data)?

To create effective test cases we have to find ‘good’ inputs (i.e., test data)

- We can not select them randomly!

There are two families/categories of approaches:

1. **White-box testing**: The tester has access to the internal structure of the software. The focus is on the internal logic and structure of the code.

2. **Black-box testing**: The tester does not have access to the internal structure of the software. The focus is on inputs and expected outputs.

### Manual vs Automated

Testers manually create and execute the test cases

- see [How ‘to write’ a test case](https://www.youtube.com/watch?v=BBmA5Qp6Ghk)

A testing framework automatically execute test scripts (implementation of test cases) that are produced by Testers
